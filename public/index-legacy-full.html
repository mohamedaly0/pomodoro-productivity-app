<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçÖ PomoFocus - Legacy Full Version (Backup)</title>
    <!-- This is an auto-created backup of the pre-cleanup index.html so you can restore or reference prior inline implementation. -->
</head>
<body>
<!-- BEGIN LEGACY CONTENT BACKUP -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçÖ PomoFocus - Professional Pomodoro Timer</title>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            transition: all 0.3s ease;
        }
        
        body.mode-work {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
        }
        
        body.mode-short {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }
        
        body.mode-long {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width,initial-scale=1" />
            <title>PomoFocus ‚Äì Local Pomodoro</title>
            <style>
                /* Base Reset */
                * { box-sizing: border-box; margin: 0; padding: 0; }
                body { font-family: system-ui,-apple-system,'Segoe UI',Roboto,sans-serif; min-height:100vh; display:flex; flex-direction:column; align-items:center; padding:2rem; background:linear-gradient(135deg,#667eea,#764ba2); color:#fff; transition:.3s; }
                body.mode-work { background:linear-gradient(135deg,#ff6b6b,#ee5a52); }
                body.mode-short_break { background:linear-gradient(135deg,#4ecdc4,#44a08d); }
                body.mode-long_break { background:linear-gradient(135deg,#667eea,#764ba2); }
                h1{font-size:3rem;font-weight:700;text-shadow:0 4px 18px rgba(0,0,0,.35);margin-bottom:.25rem}
                .subtitle{opacity:.85;margin-bottom:1.5rem}
                .layout{width:100%;max-width:1000px;display:grid;gap:1.5rem;grid-template-columns:repeat(auto-fit,minmax(300px,1fr))}
                .panel{background:rgba(255,255,255,.12);backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.25);padding:1.75rem 1.5rem;border-radius:20px;box-shadow:0 10px 30px -5px rgba(0,0,0,.4);position:relative;overflow:hidden}
                .panel:before{content:"";position:absolute;inset:0;background:radial-gradient(circle at 85% 15%,rgba(255,255,255,.25),transparent 60%);pointer-events:none}
                .timer-display{display:flex;flex-direction:column;align-items:center;gap:.5rem;margin:1.25rem 0 1.75rem}
                #timerDisplay{font-size:5rem;font-variant-numeric:tabular-nums;font-weight:300;letter-spacing:-2px;text-shadow:0 2px 12px rgba(0,0,0,.35)}
                #timerLabel{text-transform:uppercase;font-size:.9rem;letter-spacing:.25em;opacity:.8}
                .modes{display:flex;gap:.6rem;flex-wrap:wrap}
                .modes button{flex:1 1 90px;padding:.65rem .75rem;border-radius:10px;border:1px solid rgba(255,255,255,.35);background:rgba(255,255,255,.15);color:#fff;font-weight:600;cursor:pointer;backdrop-filter:blur(6px);transition:.25s;font-size:.8rem;letter-spacing:.05em}
                .modes button.active{background:#fff;color:#222;box-shadow:0 4px 14px -3px rgba(0,0,0,.5);transform:translateY(-2px)}
                .controls{display:flex;justify-content:center;gap:.75rem;flex-wrap:wrap}
                .controls button{padding:.9rem 1.4rem;font-size:.9rem;font-weight:600;border:none;border-radius:14px;cursor:pointer;background:#222;color:#fff;letter-spacing:.05em;box-shadow:0 4px 16px -4px rgba(0,0,0,.55);transition:.25s}
                .controls button.secondary{background:rgba(255,255,255,.18)}
                .controls button:disabled{opacity:.4;cursor:not-allowed;transform:none}
                .controls button:not(:disabled):hover{transform:translateY(-2px)}
                .progress{height:8px;border-radius:4px;background:rgba(255,255,255,.25);overflow:hidden;margin-top:.25rem}
                .progress > div{height:100%;width:0;background:linear-gradient(90deg,#fff,#f9f9f9);box-shadow:0 0 12px 2px rgba(255,255,255,.6) inset;transition:width 1s linear}
                .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:1rem;margin-top:1rem}
                .stat{background:rgba(255,255,255,.15);padding:.9rem .75rem;border-radius:14px;text-align:center;border:1px solid rgba(255,255,255,.25)}
                .stat h4{font-size:.65rem;letter-spacing:.15em;font-weight:600;opacity:.75;margin-bottom:.35rem;text-transform:uppercase}
                .stat .val{font-size:1.9rem;font-weight:600}
                .tasks header{display:flex;gap:.5rem;margin-bottom:.75rem}
                .tasks input{flex:1;padding:.75rem .85rem;border-radius:12px;border:1px solid rgba(255,255,255,.35);background:rgba(255,255,255,.18);color:#fff;font-size:.9rem}
                .tasks input::placeholder{color:rgba(255,255,255,.6)}
                .tasks button.add{padding:.75rem 1.1rem;border-radius:12px;border:1px solid rgba(255,255,255,.4);background:#fff;color:#222;font-weight:600;cursor:pointer;transition:.25s}
                .tasks button.add:hover{transform:translateY(-2px)}
                #taskList{display:flex;flex-direction:column;gap:.55rem;max-height:380px;overflow:auto;padding-right:.35rem}
                .task-item{display:flex;align-items:center;justify-content:space-between;padding:.75rem .85rem;border-radius:14px;background:rgba(255,255,255,.15);border:1px solid transparent;gap:.75rem;transition:.25s}
                .task-item.selected{border-color:#fff;background:rgba(255,255,255,.28)}
                .task-main{flex:1;min-width:0}
                .task-title{font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
                .task-title.done{text-decoration:line-through;opacity:.55}
                .task-meta{font-size:.65rem;letter-spacing:.1em;opacity:.6;margin-top:.15rem;text-transform:uppercase}
                .task-actions{display:flex;gap:.4rem}
                .task-actions button{background:rgba(255,255,255,.2);border:1px solid rgba(255,255,255,.35);color:#fff;padding:.45rem .55rem;border-radius:10px;cursor:pointer;font-size:.85rem;display:flex;align-items:center;justify-content:center;transition:.25s}
                .task-actions button:hover{background:rgba(255,255,255,.35);transform:translateY(-2px)}
                .empty{opacity:.65;text-align:center;padding:1.25rem;font-size:.85rem}
                .notification{position:fixed;top:1.25rem;right:1.25rem;background:#222;color:#fff;padding:.75rem 1.1rem;border-radius:12px;box-shadow:0 6px 24px -6px rgba(0,0,0,.5);opacity:0;transform:translateY(-10px);transition:.4s;pointer-events:none;font-size:.85rem;letter-spacing:.05em}
                .notification.show{opacity:1;transform:translateY(0)}
                footer{margin-top:2rem;opacity:.6;font-size:.7rem;letter-spacing:.15em;text-transform:uppercase}
                @media (max-width:680px){h1{font-size:2.3rem}#timerDisplay{font-size:3.6rem}.layout{grid-template-columns:1fr}}
            </style>
        </head>
        <body class="mode-work">
            <h1>üçÖ PomoFocus</h1>
            <p class="subtitle">Focused local Pomodoro (no external services)</p>
            <div class="layout">
                <section class="panel">
                    <div class="modes">
                        <button data-session-type="work" class="active">Work</button>
                        <button data-session-type="short_break">Short Break</button>
                        <button data-session-type="long_break">Long Break</button>
                    </div>
                    <div class="timer-display">
                        <div id="timerDisplay">25:00</div>
                        <div id="timerLabel">Focus Time</div>
                    </div>
                    <div class="progress"><div id="progressFill"></div></div>
                    <div class="controls" style="margin-top:1.2rem">
                        <button id="startTimerBtn">Start</button>
                        <button id="pauseTimerBtn" disabled>Pause</button>
                        <button id="resetTimerBtn" class="secondary">Reset</button>
                        <button id="skipTimerBtn" class="secondary">Skip</button>
                    </div>
                    <div class="stats">
                        <div class="stat"><h4>Pomodoros</h4><div class="val" id="statPomodoros">0</div></div>
                        <div class="stat"><h4>Focus</h4><div class="val" id="statFocus">0m</div></div>
                    </div>
                </section>
                <section class="panel tasks">
                    <header>
                        <input id="taskInput" placeholder="Add a task & hit Enter" />
                        <button class="add" id="addTaskBtn">Add</button>
                    </header>
                    <div id="taskList"></div>
                </section>
            </div>
            <div class="notification" id="notification"></div>
            <footer>Local Offline Mode ‚Äì Future: Auth, DB, Spotify, Calendar</footer>
            <script src="js/localAuthStub.js"></script>
            <script src="js/pomodoroCore.js"></script>
            <script src="js/localTasks.js"></script>
            <script>
                (function(){
                    const notifyEl = document.getElementById('notification');
                    function notify(msg){
                        notifyEl.textContent = msg;notifyEl.classList.add('show');
                        setTimeout(()=>notifyEl.classList.remove('show'),2500);
                    }
                    const timer = new LocalPomodoroTimer();
                    window.localTasks = new LocalTaskManager({ timer });
                    timer.onTaskCompleted = () => {};
                    document.getElementById('startTimerBtn').addEventListener('click',()=>notify('Timer started'));
                    document.getElementById('pauseTimerBtn').addEventListener('click',()=>notify('Timer paused'));
                    document.getElementById('resetTimerBtn').addEventListener('click',()=>notify('Timer reset'));
                    document.getElementById('skipTimerBtn').addEventListener('click',()=>notify('Session skipped'));
                    console.log('[PomoFocus] Local mode ready.');
                })();
            </script>
        </body>
        </html>
                    <div class="stat-label">Tasks Done</div>
                </div>
            </div>
        </div>

        <div class="task-section">
            <h3>üìù Task Manager</h3>
            
            <div class="task-input-group">
                <input type="text" class="task-input" id="taskInput" placeholder="What are you working on?">
                <button class="task-add-btn" id="addTaskBtn">‚ûï</button>
            </div>

            <div id="taskList">
                <!-- Tasks will be added here -->
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        class PomodoroApp {
            constructor() {
                this.modes = {
                    work: { duration: 25 * 60, label: 'Focus Time' },
                    short: { duration: 5 * 60, label: 'Short Break' },
                    long: { duration: 15 * 60, label: 'Long Break' }
                };
                
                this.currentMode = 'work';
                this.timeLeft = this.modes.work.duration;
                this.isRunning = false;
                this.timer = null;
                this.currentSession = null;
                
                this.stats = {
                    pomodorosCompleted: 0,
                    focusTime: 0,
                    tasksCompleted: 0
                };
                
                this.tasks = [];
                this.currentTaskId = null;
                
                this.init();
            }
            
            async init() {
                console.log('üçÖ PomoFocus initializing...');
                this.setupEventListeners();
                this.loadStats();
                await this.loadTasks();
                this.updateDisplay();
                this.updateStats();
                console.log('‚úÖ PomoFocus ready!');
            }
            
            setupEventListeners() {
                // Mode selector
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!this.isRunning) {
                            this.setMode(btn.dataset.mode);
                        }
                    });
                });
                
                // Timer controls
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                
                // Task management
                document.getElementById('addTaskBtn').addEventListener('click', () => this.addTask());
                document.getElementById('taskInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.addTask();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    
                    switch (e.key) {
                        case ' ':
                            e.preventDefault();
                            this.isRunning ? this.pause() : this.start();
                            break;
                        case 'r':
                        case 'R':
                            e.preventDefault();
                            this.reset();
                            break;
                    }
                });
            }
            
            setMode(mode) {
                this.currentMode = mode;
                this.timeLeft = this.modes[mode].duration;
                
                // Update UI
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });
                
                document.body.className = `mode-${mode}`;
                document.getElementById('timerLabel').textContent = this.modes[mode].label;
                
                this.updateDisplay();
            }
            
            async start() {
                if (!this.currentTaskId && this.tasks.length > 0) {
                    this.showNotification('Please select a task to focus on!');
                    return;
                }
                
                this.isRunning = true;
                this.timer = setInterval(() => this.tick(), 1000);
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                
                // Start session on server
                if (this.currentTaskId) {
                    await this.startSession();
                }
                
                this.showNotification(`${this.modes[this.currentMode].label} started!`);
            }
            
            pause() {
                this.isRunning = false;
                clearInterval(this.timer);
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                
                this.showNotification('Timer paused');
            }
            
            reset() {
                this.isRunning = false;
                clearInterval(this.timer);
                this.timeLeft = this.modes[this.currentMode].duration;
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                
                this.updateDisplay();
                this.showNotification('Timer reset');
            }
            
            tick() {
                this.timeLeft--;
                this.updateDisplay();
                
                if (this.timeLeft <= 0) {
                    this.complete();
                }
            }
            
            async complete() {
                this.isRunning = false;
                clearInterval(this.timer);
                
                // Update stats
                if (this.currentMode === 'work') {
                    this.stats.pomodorosCompleted++;
                    this.stats.focusTime += this.modes.work.duration / 60;
                }
                
                if (this.currentSession) {
                    await this.completeSession();
                }
                
                this.saveStats();
                this.updateStats();
                
                // Auto-advance
                this.autoAdvance();
                
                this.playNotificationSound();
                this.showNotification(`${this.modes[this.currentMode].label} completed! üéâ`);
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
            }
            
            autoAdvance() {
                if (this.currentMode === 'work') {
                    const nextMode = this.stats.pomodorosCompleted % 4 === 0 ? 'long' : 'short';
                    this.setMode(nextMode);
                } else {
                    this.setMode('work');
                }
            }
            
            updateDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('timerDisplay').textContent = timeString;
                
                // Update progress bar
                const totalDuration = this.modes[this.currentMode].duration;
                const progress = ((totalDuration - this.timeLeft) / totalDuration) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                
                // Update document title
                document.title = `${timeString} - PomoFocus`;
            }
            
            updateStats() {
                document.getElementById('pomodorosCompleted').textContent = this.stats.pomodorosCompleted;
                document.getElementById('focusTime').textContent = `${Math.floor(this.stats.focusTime)}m`;
                document.getElementById('tasksCompleted').textContent = this.stats.tasksCompleted;
            }
            
            async addTask() {
                const input = document.getElementById('taskInput');
                const title = input.value.trim();
                
                if (!title) return;
                
                try {
                    const response = await fetch('/api/tasks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ title })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.tasks.push(data.task);
                        this.renderTasks();
                        input.value = '';
                        this.showNotification('Task added successfully');
                    }
                } catch (error) {
                    console.error('Error adding task:', error);
                    const newTask = {
                        id: Date.now(),
                        title,
                        completed: false,
                        pomodoroCount: 0
                    };
                    this.tasks.push(newTask);
                    this.renderTasks();
                    input.value = '';
                    this.showNotification('Task added (offline mode)');
                }
            }
            
            async deleteTask(taskId) {
                try {
                    await fetch(`/api/tasks/${taskId}`, { method: 'DELETE' });
                } catch (error) {
                    console.error('Error deleting task:', error);
                }
                
                this.tasks = this.tasks.filter(task => task.id !== taskId);
                if (this.currentTaskId === taskId) {
                    this.currentTaskId = null;
                }
                this.renderTasks();
                this.showNotification('Task deleted');
            }
            
            async toggleTask(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                task.completed = !task.completed;
                
                try {
                    await fetch(`/api/tasks/${taskId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ completed: task.completed })
                    });
                } catch (error) {
                    console.error('Error updating task:', error);
                }
                
                if (task.completed) {
                    this.stats.tasksCompleted++;
                    this.updateStats();
                    this.saveStats();
                }
                
                this.renderTasks();
                this.showNotification(task.completed ? 'Task completed!' : 'Task reopened');
            }
            
            selectTask(taskId) {
                this.currentTaskId = taskId;
                this.renderTasks();
                this.showNotification('Task selected for focus session');
            }
            
            renderTasks() {
                const taskList = document.getElementById('taskList');
                
                if (this.tasks.length === 0) {
                    taskList.innerHTML = '<p style="text-align: center; opacity: 0.7; padding: 20px;">No tasks yet. Add one above! üìù</p>';
                    return;
                }
                
                taskList.innerHTML = this.tasks.map(task => `
                    <div class="task-item ${task.id === this.currentTaskId ? 'selected' : ''}" data-task-id="${task.id}">
                        <div class="task-content">
                            <div class="task-title ${task.completed ? 'completed' : ''}">${task.title}</div>
                            <div class="task-meta">${task.pomodoroCount || 0} pomodoros completed</div>
                        </div>
                        <div class="task-actions">
                            <button class="task-btn" onclick="app.selectTask(${task.id})" title="Select for focus">
                                üéØ
                            </button>
                            <button class="task-btn" onclick="app.toggleTask(${task.id})" title="Toggle completion">
                                ${task.completed ? '‚Ü©Ô∏è' : '‚úÖ'}
                            </button>
                            <button class="task-btn" onclick="app.deleteTask(${task.id})" title="Delete task">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `).join('');
            }
            
            async loadTasks() {
                try {
                    const response = await fetch('/api/tasks');
                    const data = await response.json();
                    
                    if (data.success) {
                        this.tasks = data.tasks;
                        this.renderTasks();
                    }
                } catch (error) {
                    console.error('Error loading tasks:', error);
                    this.showNotification('Running in offline mode');
                }
            }
            
            async startSession() {
                if (!this.currentTaskId) return;
                
                try {
                    const response = await fetch('/api/sessions/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            taskId: this.currentTaskId,
                            sessionType: this.currentMode,
                            duration: this.modes[this.currentMode].duration / 60
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.currentSession = data.session;
                    }
                } catch (error) {
                    console.error('Error starting session:', error);
                }
            }
            
            async completeSession() {
                if (!this.currentSession) return;
                
                try {
                    await fetch(`/api/sessions/complete/${this.currentSession.id}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            actualDuration: this.modes[this.currentMode].duration / 60
                        })
                    });
                    
                    if (this.currentMode === 'work') {
                        const task = this.tasks.find(t => t.id === this.currentTaskId);
                        if (task) {
                            task.pomodoroCount = (task.pomodoroCount || 0) + 1;
                            this.renderTasks();
                        }
                    }
                } catch (error) {
                    console.error('Error completing session:', error);
                }
                
                this.currentSession = null;
            }
            
            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            playNotificationSound() {
                try {
                    const context = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = context.createOscillator();
                    const gain = context.createGain();
                    
                    oscillator.connect(gain);
                    gain.connect(context.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gain.gain.setValueAtTime(0.3, context.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);
                    
                    oscillator.start(context.currentTime);
                    oscillator.stop(context.currentTime + 0.5);
                } catch (error) {
                    console.log('Audio not available');
                }
            }
            
            saveStats() {
                localStorage.setItem('pomodoroStats', JSON.stringify(this.stats));
            }
            
            loadStats() {
                const saved = localStorage.getItem('pomodoroStats');
                if (saved) {
                    this.stats = { ...this.stats, ...JSON.parse(saved) };
                }
            }
        }
        
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new PomodoroApp();
            window.pomodoroApp = app;
            console.log('üéØ Keyboard shortcuts:');
            console.log('   Space - Start/Pause timer');
            console.log('   R - Reset timer');
            console.log('   Enter - Add task (when typing)');
        });
    </script>
</body>
</html>
<!-- END LEGACY CONTENT BACKUP -->
</body>
</html>
